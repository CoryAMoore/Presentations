<#
.SYNOPSIS
Author: 	Craig Porteous
Date:		Aug 2017	
PowerBI_Datasets-SQL

This script retrieves the latest refresh information & statuses from all datasets inside all Workspaces that the 
provided user has access to.

.DESCRIPTION
This script will iterate through all datasets in all Workspaces within Power BI that the chosen user has access to.
It will return & store the latest refresh information for each relevant dataset. Live connection and Direct Query
datasets are excluded as they do not have refresh information.

.PARAMETER userName
This is the Power BI user that the API will use to query workspaces and datasets. The datasets & groups that are returned
are restricted by this user's permissions

.PARAMETER tenantID
# To find your Office 365 tenant ID in the Azure AD portal
# - Log in to Microsoft Azure as an administrator.
# - In the Microsoft Azure portal, click Azure Active Directory.
# - Under Manage, click Properties. The tenant ID is shown in the Directory ID box.

.PARAMETER clientId
This is the ID generated by the Power BI App created above. It can also be found from
within Azure

.PARAMETER client_secret
This is also generated when the Power BI App is created & must be noted as it is
irretrievable once you leave the page

.PARAMETER DBserver
Destination Database Server for the refresh data

.PARAMETER Database
Destination Database 

.PARAMETER Schema
Destination Database Schema (Defaulted to dbo)

.PARAMETER Schema
Destination Table name

.EXAMPLE
.\PowerBI_Datasets-SQL -userName User@Domain.com

.NOTES
# Prerequisites
#-------------------------------------------------------------------------------
# Client ID & Client Secret can be obtained from creating a PowerBI app:
# https://dev.powerbi.com/apps
# App Type: Web App / API
#-------------------------------------------------------------------------------
#>

[CmdletBinding()]
param
(
    [Parameter(Mandatory=$true)]
    [string]
    $userName = "$(Read-Host 'Power BI Account')",
    
    [string]
    $tenantID,
    
    [Parameter(Mandatory=$true)]
    [string]
    $clientId,

    [Parameter(Mandatory=$true)]
    [string]
    $client_secret,

    #Database settings
    [Parameter(Mandatory=$true)]
    [string]
    $DBserver = 'DATABASESERVER',
    
    [Parameter(Mandatory=$true)]
    [string]
    $Database = 'DATABASE',
    
    [string]
    $schema = 'dbo',

    [Parameter(Mandatory=$true)]
    [string]
    $table = 'PowerBI_Datasets'
)

begin { 
    Write-Verbose 'Add Authentication & Notification Functions'
    . ".\Get-PBIAuthTokenUnattended.ps1"
	. ".\Invoke-AlertEmail.ps1"
    
    if($tenantID = $null)
    {
        Write-Verbose 'Split the string on the username to get the Domain'
        $tenantDomain = $userName.Split("@")[1]
        Write-Verbose 'Querying Azure anonymously (this may not work for ALL tenant domains. Eg. Those that use .onmicrosoft.com)'
        $tenantID = (Invoke-WebRequest https://login.windows.net/$($tenantDomain)/.well-known/openid-configuration|ConvertFrom-Json).token_endpoint.Split('/')[3]
    }        
}
process {	
	try{
        Write-Verbose 'Authenticate to Power BI using Get-PBIAuthTokenUnattended'
        $auth = Get-PBIAuthTokenUnattended -userName $userName -tenantID $tenantID -clientId $clientId -client_secret $client_secret
        
		Write-Verbose 'Building Rest API header with authorization token'
        $authHeader = @{
            'Content-Type'='application/json'
            'Authorization'='Bearer ' + $auth.access_token
            }
        }
    catch {
        Write-Error 'Authentication failure'
        $script = $MyInvocation.MyCommand.Name	
        $Subject = "$script Error: Authentication Failure"
        $htmlContent = $_.Exception.Message
        Invoke-AlertEmail -title $script -htmlContent $htmlContent -subject $subject -alertColour "#FF5733"
        throw $_
    }

    try{
        Write-Verbose 'Retrieve all Power BI Workspaces'
        $uri = "https://api.powerbi.com/v1.0/myorg/groups"
        $groups = Invoke-RestMethod -Uri $uri -Headers $authHeader -Method GET

        #Declare final Array
        $PBIDatasets = @()

        Write-Verbose 'Loop through Workspaces to query datasets'
        foreach($group in $groups.value)
        {
            Write-Verbose 'Build Group path for API call'   
            $groupsPath = "myorg/groups/$($group.id)"
            
            Write-Verbose 'Build Dataset API String'
            $uri = "https://api.powerbi.com/v1.0/$groupsPath/datasets"
            Write-Verbose 'Return all datasets in Workspace'
            $datasets = Invoke-RestMethod -Uri $uri -Headers $authHeader -Method GET

            Write-Verbose 'Loop through datasets to query refresh info'
            foreach($dataset in $datasets.value)
            {
                if($dataset.isRefreshable -eq $true) #We can only return refresh info on datasets that can be refreshed
                {
                    Write-Verbose 'Build Refresh API String'
                    $uri2 = "https://api.powerbi.com/v1.0/$groupsPath/datasets/$($dataset.id)/refreshes"
                    Write-Verbose 'Return refresh info for each dataset'
                    $refreshes = Invoke-RestMethod -Uri $uri2 -Headers $authHeader -Method GET 
                    
                    Write-Verbose 'Add last refresh info to array'
                    $PBIDatasets += New-Object PsObject -Property @{
                        "GroupName"="$($group.name)";
                        "GroupID"="$($group.id)";
                        "DatasetName"="$($dataset.name)";
                        "DatasetID"="$($dataset.id)";
                        "DatasetOwner"="$($dataset.configuredBy)";
                        "LastRefreshType"="$($refreshes.value[0].refreshType)";
                        "LastRefreshStart"="$($refreshes.value[0].startTime)";
                        "LastRefreshEnd"="$($refreshes.value[0].endTime)";
                        "LastRefreshStatus"="$($refreshes.value[0].status)";
                    }
                }
            }
            $datasets = $null
        }		
	}
	catch{
		Write-Error "Data collection failure"
		$script = $MyInvocation.MyCommand.Name	
		$Subject = "$script Error: Data Collection Failure"		
        $htmlContent = $_.Exception.Message
        Invoke-AlertEmail -title $script -htmlContent $htmlContent -subject $subject -alertColour "#FF5733"
		throw $_
	}

	try {
        Write-Verbose "Open connection to Database server"
        $ConnUPDATE = New-Object System.Data.SQLClient.SQLConnection
        $ConnUPDATE.ConnectionString = "server='$DBserver';database='$Database';trusted_connection=true;"
        $ConnUPDATE.Open()
        #------------------------------------------------------------------------------- 
        Write-Verbose "Create destination table if it does not exist"

        $sqlCREATE = "IF NOT EXISTS(SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'$($schema).$($table)'))
                CREATE TABLE $($schema).$($table)(
                [GroupID] [varchar](100) NOT NULL,
                [GroupName] [varchar](250) NOT NULL,
                [DatasetID] [varchar](100) NULL,
                [DatasetName] [varchar](250) NULL,
                [DatasetOwner] [varchar](100) NULL,
                [DatasetDateAdded] [datetime] NULL,
                [LastRefreshType] [varchar](100) NULL,
                [LastRefreshStart] [datetime] NULL,
                [LastRefreshEnd] [datetime] NULL,
                [LastRefreshStatus] [varchar](100) NULL
                )
                GO"
        $Command = New-Object System.Data.SQLClient.SQLCommand($sqlCREATE, $ConnUPDATE)
        #$Command.CommandText
        Write-Verbose "CREATE destination table if it doesn't exist"
        $numROWS = $Command.ExecuteNonQuery()
        #-------------------------------------------------------------------------------              
        #Add Groups to SQL Table
        foreach($record in $PBIDatasets){
            Write-Verbose "Need to escape ' characters used in name fields. IE. John O'Brien"
            $record.GroupName = $record.GroupName.replace("'","''")
			$record.DatasetName = $record.DatasetName.replace("'","''")
			$record.DatasetOwner = $record.DatasetOwner.replace("'","''")
            Write-Verbose "Build SQL Query"
            $sqlINSERT ="
                if not exists (select 1 from $($database).$($schema).$($table) where [GroupID] = '$($record.GroupID)' AND [DatasetID] = '$($record.DatasetID)') 
                    begin 
                    INSERT INTO $($database).$($schema).$($table)([GroupID], [GroupName], [DatasetID], [DatasetName], [DatasetOwner], [DatasetDateAdded], [LastRefreshType], [LastRefreshStart], [LastRefreshEnd], [LastRefreshStatus])
                    SELECT 
                        '$($record.GroupID)',
                        '$($record.GroupName)',
                        '$($record.DatasetID)',
                        '$($record.DatasetName)',
                        '$($record.DatasetOwner)',
                        Getdate(),
                        '$($record.LastRefreshType)',
                        '$($record.LastRefreshStart)',
                        '$($record.LastRefreshEnd)',
                        '$($record.LastRefreshStatus)'
                    end
                else if exists (select 1 from $($database).$($schema).$($table) where [GroupID] = '$($record.GroupID)' AND [DatasetID] = '$($record.DatasetID)'
                        AND [LastRefreshStart] <> '$($record.LastRefreshStart)') 
                    begin 
                    UPDATE $($database).$($schema).$($table)
                    SET 
                        LastRefreshType = '$($record.LastRefreshType)',
                        LastRefreshStart = '$($record.LastRefreshStart)',
                        LastRefreshEnd = '$($record.LastRefreshEnd)',
                        LastRefreshStatus = '$($record.LastRefreshStatus)'
                    WHERE [DatasetID] = '$($record.DatasetID)'
                    end"
            $Command = New-Object System.Data.SQLClient.SQLCommand($sqlINSERT, $ConnUPDATE)
            #$Command.CommandText
            Write-Verbose "Execute SQL"
            $numROWS = $Command.ExecuteNonQuery()
        }
        $ConnUPDATE.Close
	}
	catch {
		Write-Error "Data Update failure"
		$script = $MyInvocation.MyCommand.Name	
		$Subject = "$script Error: Data Update Failure"
        $htmlContent = $_.Exception.Message
        Invoke-AlertEmail -title $script -htmlContent $htmlContent -subject $subject -alertColour "#FF5733"
        throw $_
	}
}